/********************************************************
 * An example source module to accompany...
 *
 * "Using POSIX Threads: Programming with Pthreads"
 *     by Brad nichols, Dick Buttlar, Jackie Farrell
 *     O'Reilly & Associates, Inc.
 *  Modified by A.Kostin
 ********************************************************
 * mutex.c
 *
 * Simple multi-threaded example with a mutex lock.
 */
#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

// Объявления функций
void do_one_thing(int *);
void do_another_thing(int *);
void do_wrap_up(int);

// Глобальные переменные
int common = 0; /* Общая переменная для двух потоков */
int r1 = 0, r2 = 0, r3 = 0; /* Дополнительные переменные */

// Инициализация мьютекса для синхронизации доступа к общим данным
pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;

int main() {
  pthread_t thread1, thread2; // Дескрипторы потоков

  // Создание первого потока, который выполняет функцию do_one_thing
  if (pthread_create(&thread1, NULL, (void *)do_one_thing,
			  (void *)&common) != 0) {
    perror("pthread_create"); // Вывод ошибки если создание потока не удалось
    exit(1); // Завершение программы с кодом ошибки
  }

  // Создание второго потока, который выполняет функцию do_another_thing
  if (pthread_create(&thread2, NULL, (void *)do_another_thing,
                     (void *)&common) != 0) {
    perror("pthread_create");
    exit(1);
  }

  // Ожидание завершения первого потока
  if (pthread_join(thread1, NULL) != 0) {
    perror("pthread_join");
    exit(1);
  }

  // Ожидание завершения второго потока
  if (pthread_join(thread2, NULL) != 0) {
    perror("pthread_join");
    exit(1);
  }

  // Вывод финального результата после завершения обоих потоков
  do_wrap_up(common);

  return 0;
}

// Функция, выполняемая первым потоком
void do_one_thing(int *pnum_times) {
  int i, j, x;
  unsigned long k;
  int work; // Локальная переменная для работы
  
  // Цикл из 50 итераций, каждая итерация увеличивает общую переменную
  for (i = 0; i < 50; i++) {

    ////////////////
    // pthread_mutex_lock(&mut);
    ////////////////
    
    printf("doing one thing\n"); // Сообщение от первого потока
    
    // Чтение значения общей переменной в локальную переменную
    work = *pnum_times;
    printf("counter = %d\n", work);
    
    // Увеличение локальной переменной
    work++; 
    
    // ДЛИННЫЙ ЦИКЛ: Имитация длительной операции
    // Во время выполнения этого цикла планировщик может переключить контекст
    for (k = 0; k < 500000; k++)
      ;          
    
    // Запись измененного значения обратно в общую переменную
    *pnum_times = work; 
    
    //////////////////
    // pthread_mutex_unlock(&mut);
    /////////////////


    // Без разблокировки мьютекса другие потоки не могут войти в критическую секцию
  }
}

// Функция, выполняемая вторым потоком (аналогична первой)
void do_another_thing(int *pnum_times) {
  int i, j, x;
  unsigned long k;
  int work;
  
  for (i = 0; i < 50; i++) {
    //////////////////////////////
    // pthread_mutex_lock(&mut);
    /////////////////////////////
    
    printf("doing another thing\n"); // Сообщение от второго потока
    
    // КРИТИЧЕСКАЯ СЕКЦИЯ НАЧАЛО:
    // Тот же процесс чтения-изменения-записи общей переменной
    work = *pnum_times;
    printf("counter = %d\n", work);
    work++; 
    
    // Длительная операция - точка возможного переключения контекста
    for (k = 0; k < 500000; k++)
      ;                
    
    *pnum_times = work; 
    // КРИТИЧЕСКАЯ СЕКЦИЯ КОНЕЦ:
    
    //////////////////////////
    // pthread_mutex_unlock(&mut);
    //////////////////////////
  }
}

// Функция для вывода финального результата
void do_wrap_up(int counter) {
  int total;
  // Ожидаемое значение: 100 (50 итераций × 2 потока)
  // Фактическое значение без мьютекса: меньше 100 из-за состояния гонки
  printf("All done, counter = %d\n", counter);
}

/*
КОММЕНТАРИИ К ПОВЕДЕНИЮ ПРОГРАММЫ:

БЕЗ МЬЮТЕКСА (текущее состояние):
- Возникает состояние гонки (race condition)
- Оба потока одновременно работают с общей переменной common
- Потеря updates: когда оба потока читают одно значение, 
  увеличивают его и записывают обратно, один инкремент теряется
- Финальное значение common будет меньше 100

С МЬЮТЕКСОМ (раскомментировать pthread_mutex_lock/unlock):
- Критическая секция защищена
- Только один поток может выполнять операции с common в любой момент времени
- Финальное значение common всегда равно 100
- Программа работает медленнее из-за синхронизации

ВЫВОД:
-- Без синхронизации: программа быстрее, но результаты некорректны из-за состояния гонки
-- С синхронизацией: программа медленнее, но результаты всегда правильные
-- Мьютекс обеспечивает корректный доступ к общим данным в многопоточной среде

ПРОБЛЕМА СОСТОЯНИЯ ГОНКИ:
Поток 1: читает common=5
Поток 2: читает common=5  
Поток 1: увеличивает до 6
Поток 2: увеличивает до 6
Поток 1: записывает 6
Поток 2: записывает 6
РЕЗУЛЬТАТ: common=6 (вместо 7) - один инкремент потерян
*/